---
title: "THE BOUNCER&apos;S MEMORY: THE DATA STRUCTURE THAT NEVER FORGETS"
date: "2024.12.26"
category: DATA STRUCTURES
readTime: "14 MIN"
---

# THE BANNED ARTIST

The line stretches around the block. Hundreds of people waiting to get into the club. At the door stands a bouncer with an impossible job.

There are 10 million people on the banned list. Ten million names of people who, for various reasons, can never enter this club again. The bouncer needs to check every single person against that list.

The obvious solution is a database lookup. But the database is massive. Each lookup takes 30 seconds. The line grows longer. People get angry. Fights break out. The club loses money.

What if the bouncer could check ANY name against those 10 million entries in microseconds, using only a few kilobytes of memory?

There&apos;s a catch. Sometimes the bouncer will say &quot;you might be banned&quot; to someone who isn&apos;t. But the bouncer will NEVER let a truly banned person through.

That asymmetry—false accusations allowed, false exonerations forbidden—is the contract of a Bloom filter. And it turns out to be extraordinarily useful.

# THE MEMORY PALACE

The bouncer builds a strange device. Instead of keeping a list of names, they install a wall of light switches. One thousand switches, all initially in the OFF position.

When someone gets banned, the bouncer doesn&apos;t write down their name. Instead, they perform three rituals:

They run the banned person&apos;s name through the first ritual—call it a hash function—and it produces a number: 147. They flip switch 147 ON.

They run the name through the second ritual. It produces: 582. They flip switch 582 ON.

They run the name through the third ritual. It produces: 831. They flip switch 831 ON.

The name &quot;JOHN_DOE&quot; is now encoded in the wall. Not as letters, but as a pattern of lit switches: 147, 582, 831.

Add another banned person: &quot;JANE_SMITH&quot;. The three rituals produce: 147, 299, 766. Switch 147 was already on—no problem. Flip 299 and 766 ON.

Notice something important: switch 147 is now lit for BOTH banned people. There&apos;s no way to tell, just by looking at the wall, who turned it on. The switches remember that they were flipped. They don&apos;t remember who flipped them.

This is the Bloom filter. A bit array where adding an item means setting bits, not storing the item itself.

# THE RECOGNITION

When someone approaches the door, the bouncer performs the same three rituals on their name.

Check switch 147. ON.
Check switch 582. ON.
Check switch 831. ON.

All three switches that correspond to this name are ON. The bouncer says: &quot;Step aside. You might be on the banned list.&quot;

But what if someone named &quot;ALEX_CHEN&quot; approaches? Alex was never banned. The bouncer performs the three rituals:

Check switch 147. ON. (Lit by JOHN_DOE)
Check switch 582. ON. (Lit by JOHN_DOE)
Check switch 766. ON. (Lit by JANE_SMITH)

All three switches are ON. But ALEX_CHEN was never added to the banned list. This is a false positive. Alex gets stopped even though they shouldn&apos;t be.

Now consider &quot;BOB_WILSON&quot;. Never banned. The three rituals produce: 147, 299, 400.

Check switch 147. ON.
Check switch 299. ON.
Check switch 400. OFF.

One switch is OFF. The bouncer knows with absolute certainty: BOB_WILSON is NOT on the banned list. If Bob were banned, all three of Bob&apos;s switches would have been flipped ON when Bob was added. Since switch 400 is OFF, Bob was never added.

This is the guarantee. If ANY switch is OFF, the person is definitely not in the set. If ALL switches are ON, the person MIGHT be in the set—or might be the victim of an unfortunate collision.

# THE FALSE ACCUSATION

Why do false positives happen? Because the switches don&apos;t track provenance.

When JOHN_DOE is banned, switches 147, 582, and 831 light up. When JANE_SMITH is banned, switches 147, 299, and 766 light up. The wall now has five lit switches: 147, 299, 582, 766, 831.

Along comes ALEX_CHEN, whose ritual numbers are 147, 582, 766. All three happen to be lit—not because Alex was added, but because JOHN_DOE lit 147 and 582, and JANE_SMITH lit 766. The switches that correspond to ALEX_CHEN happen to all be on, purely by coincidence.

This is a collision in probability space. As you add more people to the banned list, more switches light up. As more switches light up, the probability of a random person triggering all their switches by accident increases.

Eventually, if you add enough people, almost every switch is ON. At that point, almost everyone looks banned. The Bloom filter has become useless.

The art of using a Bloom filter is choosing the right size. Too small, and it fills up with false positives. Too large, and you&apos;re wasting memory. There&apos;s a mathematical sweet spot.

# THE UNFORGIVING WALL

Here is the brutal limitation: you cannot remove a name from the banned list.

Suppose you want to unban JOHN_DOE. Which switches do you turn off?

Switch 147 was lit by JOHN_DOE. But wait—it was also lit by JANE_SMITH. If you turn it off, JANE_SMITH&apos;s pattern is corrupted. Her check might now return &quot;not banned&quot; even though she&apos;s still on the list.

Switch 582 was lit only by JOHN_DOE. Safe to turn off? Maybe. But you don&apos;t know that. The switches don&apos;t record who turned them on.

Turn off any switch, and you risk creating false negatives. People who ARE on the banned list might now slip through. And false negatives are the one thing a Bloom filter cannot tolerate.

The filter has perfect recall: everyone who was added will be caught. It has imperfect precision: some innocent people will be falsely accused. This tradeoff is acceptable. The reverse would be catastrophic.

There are extensions—Counting Bloom filters, Cuckoo filters—that allow deletion by tracking how many times each switch was flipped. But the basic Bloom filter is append-only. A one-way memory. Once you&apos;ve seen someone, you can never truly forget them.

# THE MATHEMATICS OF UNCERTAINTY

The false positive rate isn&apos;t random. It&apos;s calculable with precision.

Let m be the number of switches. Let n be the number of items you&apos;ve added. Let k be the number of rituals you perform per item.

After adding n items, each performing k rituals, the probability that a specific switch is still OFF is approximately e to the power of negative kn over m.

The false positive probability—the chance that a random person triggers all k of their switches—is the probability that all k switches happen to be ON: one minus that probability, raised to the k power.

This formula is your dial. Want fewer false positives? Use more switches. Want faster checks? Use fewer rituals. The optimal number of rituals, given your switches and items, is approximately 0.693 times the ratio of switches to items.

In practice: if you want a 1% false positive rate, you need about 10 switches per item. A million items requires 10 million switches—about 1.2 megabytes. For a 0.1% rate, you need about 15 switches per item. For 0.01%, about 20.

Each order of magnitude improvement in accuracy costs about 50% more memory. The returns diminish, but the relationship is predictable.

# THE TRADEOFF DIAL

Every Bloom filter is a negotiation between three forces.

Space: More switches means fewer collisions. But memory isn&apos;t free. A database with 100 million URLs needs 120 megabytes for a 1% false positive rate. That might fit in L3 cache. It might not.

Accuracy: Lower false positive rates require more switches and more rituals. But at some point, you&apos;re spending computation on diminishing returns. A 0.001% rate might be overkill if you&apos;re just trying to avoid unnecessary database lookups.

Speed: More rituals means more hash computations per check. But fewer rituals means more collisions. The optimal balance depends on how expensive your hash function is versus how expensive a false positive is.

You cannot escape this tradeoff. You can only choose which sacrifices to make. The Bloom filter forces you to confront a fundamental truth: perfect certainty requires infinite resources. Probabilistic certainty requires a budget.

# THE REAL BOUNCERS

Chrome&apos;s Safe Browsing feature needs to check every URL you visit against a list of millions of known malicious websites. Downloading that entire list to every browser is impractical. But a Bloom filter representing those URLs? A few megabytes.

Chrome downloads the Bloom filter, checks URLs locally. If the filter says &quot;definitely safe,&quot; the page loads instantly. If the filter says &quot;might be malicious,&quot; Chrome does a full check with Google&apos;s servers. The filter handles 99% of cases locally. Only the suspicious 1% requires network traffic.

Medium uses Bloom filters to track which articles you&apos;ve already seen. Before recommending a story, they check: has this user seen this before? A full database lookup for every recommendation is too slow. A Bloom filter check is instant. Occasionally you&apos;ll see a story twice—a false negative in the &quot;already seen&quot; check—but that&apos;s acceptable.

Cassandra and HBase use Bloom filters to avoid disk reads. Before scanning a disk file for a key, they check the Bloom filter. If the filter says &quot;definitely not here,&quot; they skip the file entirely. Disk I/O avoided. If the filter says &quot;might be here,&quot; they do the read. Occasionally they&apos;ll read a file that doesn&apos;t contain the key—a false positive—but that&apos;s far cheaper than reading every file for every query.

Akamai uses Bloom filters to prevent cache pollution. An object must appear in the Bloom filter—must have been requested at least once—before being cached. This prevents one-hit-wonders from evicting frequently-accessed content. The filter is the bouncer at the cache door.

Bitcoin uses Bloom filters for lightweight wallet clients. Instead of downloading every transaction in the blockchain, SPV clients request only transactions that match their addresses. The filter represents the addresses. Some false positives slip through—transactions that look like they might be relevant but aren&apos;t—but the bandwidth savings are enormous.

# THE MENTAL MODEL

When someone asks you about Bloom filters, hold this image.

A bouncer with a wall of light switches. A thousand switches, initially all OFF.

When someone is banned, the bouncer runs their name through three rituals. Each ritual produces a switch number. Those switches get flipped ON. The name is encoded in the pattern.

When someone arrives at the door, the bouncer runs the same three rituals. If ALL three switches are ON: &quot;You might be on the list. Step aside.&quot; If ANY switch is OFF: &quot;You&apos;re definitely not on the list. Come in.&quot;

The switches never turn off. You can never truly delete. And sometimes, purely by statistical chance, the switches that correspond to an innocent person happen to all be lit by other people.

That&apos;s the contract of probabilistic memory. Perfect recall of what was added. Imperfect certainty about what wasn&apos;t. A bouncer who never lets a real threat through, but occasionally detains an innocent.

In exchange for this imperfection, you get speed and space that deterministic data structures cannot match. The Bloom filter trades certainty for efficiency. And in a world of finite memory and infinite data, that trade often makes sense.

---

*Head to the Lab to build your own Bloom filter. Add names. Check names. Watch the bits light up. See false positives emerge as the filter fills. The bouncer awaits.*
