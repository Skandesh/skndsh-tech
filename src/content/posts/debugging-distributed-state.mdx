---
title: "THE GHOST IN THE SHELL: DEBUGGING DISTRIBUTED STATE"
date: "2024.11.24"
category: SYSTEMS
readTime: "12 MIN"
---

# THE LIE OF &quot;NOW&quot;

If you ask two computers &quot;what time is it?&quot;, they will give you different answers. In a distributed system (like a real-time collaborative editor), this tiny discrepancy—even just a few milliseconds—is catastrophic. It breaks the concept of &quot;now&quot;.

I recently built a collaborative text editor using CRDTs (Conflict-free Replicated Data Types). We hit a bug where users would see text flicker or disappear. The root cause? We trusted the system clock. We assumed that if Event A happened at 12:00:01 and Event B at 12:00:02, then A happened before B. In distributed systems, this assumption is false.

# CAUSALITY VS. TIME

To fix this, we have to stop thinking about &quot;time&quot; (when something happened) and start thinking about &quot;causality&quot; (what caused what). If I reply to your message, my message is *caused by* yours. It doesn&apos;t matter what the clock says; my message *must* come after yours.

We track this using **Vector Clocks**. A Vector Clock isn&apos;t a single number; it&apos;s an array of counters, one for each node in the system. It looks like this: `[Alice: 2, Bob: 1]`.

```typescript
class VectorClock {
  private clocks: Map<string, number>;
  private nodeId: string;

  constructor(nodeId: string) {
    this.nodeId = nodeId;
    this.clocks = new Map();
    this.clocks.set(nodeId, 0);
  }

  // When we do something, we increment our own clock
  increment() {
    const current = this.clocks.get(this.nodeId) || 0;
    this.clocks.set(this.nodeId, current + 1);
    return this.clone();
  }

  // When we receive a message, we merge the clocks
  // This is the magic: we take the MAXIMUM of what we know vs what they know
  merge(other: VectorClock) {
    for (const [node, time] of other.clocks) {
      const localTime = this.clocks.get(node) || 0;
      this.clocks.set(node, Math.max(localTime, time));
    }
  }

  // Compare two clocks to see if they are concurrent (conflict!)
  // Returns: 'before', 'after', or 'concurrent'
  compare(other: VectorClock): 'before' | 'after' | 'concurrent' {
    let isBefore = false;
    let isAfter = false;

    // Check every node's time
    const allNodes = new Set([...this.clocks.keys(), ...other.clocks.keys()]);

    for (const node of allNodes) {
      const myTime = this.clocks.get(node) || 0;
      const theirTime = other.clocks.get(node) || 0;

      if (myTime < theirTime) isBefore = true;
      if (myTime > theirTime) isAfter = true;
    }

    // If I have some newer info AND they have some newer info,
    // neither happened "before" the other. They are concurrent.
    if (isBefore && isAfter) return 'concurrent';
    return isBefore ? 'before' : 'after';
  }
}
```

This `compare` function is the key. If two operations are &quot;concurrent&quot;, it means neither caused the other—they happened independently (like two people talking at once). This is where the &quot;ghost&quot; lived. By detecting concurrency, we could deterministically resolve conflicts (e.g., sort by User ID) instead of letting network latency decide the winner.
