import fs from 'fs';
import path from 'path';
import { glob } from 'glob';
import matter from 'gray-matter';

interface CreativeWorkMeta {
  slug: string;
  title: string;
  type: 'generative' | 'photography' | 'writing';
  category: string;
  date: string;
  thumbnail: string;
  featured?: boolean;
  interactive?: boolean;
  componentPath?: string;
  images?: string[];
  readTime?: string;
}

async function generateManifest() {
  const contentDir = path.join(process.cwd(), 'src/content/creative');
  const outputPath = path.join(process.cwd(), 'src/generated/creative-manifest.ts');

  // Ensure directories exist
  const dirs = ['generative', 'photography', 'writing'];
  for (const dir of dirs) {
    const fullPath = path.join(contentDir, dir);
    if (!fs.existsSync(fullPath)) {
      fs.mkdirSync(fullPath, { recursive: true });
    }
  }

  const outputDir = path.dirname(outputPath);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  // Find all MDX files in subdirectories
  const files = await glob('**/*.mdx', { cwd: contentDir });

  const works: CreativeWorkMeta[] = [];

  for (const file of files) {
    const filePath = path.join(contentDir, file);
    const content = fs.readFileSync(filePath, 'utf-8');
    const { data } = matter(content);

    // Extract type from directory structure
    const parts = file.split('/');
    const type = parts[0] as 'generative' | 'photography' | 'writing';
    const slug = parts[parts.length - 1].replace('.mdx', '');

    works.push({
      slug,
      title: data.title || slug.toUpperCase().replace(/-/g, '_'),
      type,
      category: data.category || type.toUpperCase(),
      date: data.date || new Date().toISOString().split('T')[0].replace(/-/g, '.'),
      thumbnail: data.thumbnail || '/images/creative/placeholder.jpg',
      featured: data.featured || false,
      interactive: data.interactive || false,
      componentPath: data.componentPath || undefined,
      images: data.images || undefined,
      readTime: data.readTime || undefined,
    });
  }

  // Sort by date descending, featured first
  works.sort((a, b) => {
    if (a.featured && !b.featured) return -1;
    if (!a.featured && b.featured) return 1;
    const dateA = a.date.replace(/\./g, '');
    const dateB = b.date.replace(/\./g, '');
    return dateB.localeCompare(dateA);
  });

  // Generate TypeScript file
  const output = `// AUTO-GENERATED FILE - DO NOT EDIT
// Generated by scripts/generate-creative-manifest.ts

import type { CreativeWork, WorkType } from '@/types/creative';

export const creativeManifest: CreativeWork[] = ${JSON.stringify(works, null, 2)};

export const getWorkBySlug = (slug: string) =>
  creativeManifest.find(work => work.slug === slug);

export const getWorksByType = (type: WorkType) =>
  creativeManifest.filter(work => work.type === type);

export const getFeaturedWorks = () =>
  creativeManifest.filter(work => work.featured);

export const getAllSlugs = () =>
  creativeManifest.map(work => work.slug);
`;

  fs.writeFileSync(outputPath, output);
  console.log(`Generated creative manifest with ${works.length} works`);
}

generateManifest().catch(console.error);
